set.seed(123)  # Фиксируем случайные значения для повторяемости эксперимента

# Задание 1 ----

# Задаем параметры
r <- 0.01  # Процентная ставка
N <- 200   # Количество периодов
B0 <- 1    # Начальная сумма на счете

# Создаем вектор для хранения последовательности Bn
B <- numeric(N + 1)  # Вектор длины N+1
B[1] <- B0           # Первое значение - начальная сумма

# Рассчитываем последовательность для каждого периода
for (n in 2:(N + 1)) {
  B[n] <- (1 + r) * B[n - 1]  
}

# Строим график изменения Bn
plot(0:N, B, type = "l", col = "blue", lwd = 2,
     xlab = "Период n", ylab = "Значение Bn",
     main = "Изменение банковского счета при r = 0.01")
grid()  # Добавляем сетку

# Задание 2 ----

# Параметры для акций
a <- -0.3  # Доходность, если не повезло
b <- 0.8   # Доходность, если повезло
p <- 0.4   # Вероятность удачного исхода
S0 <- 1    # Начальная цена акции

# Создаем вектор для последовательности Sn
S <- numeric(N + 1)  # Вектор для хранения значений Sn
S[1] <- S0           # Начальная цена

# Генерируем последовательность случайных доходностей
rho <- numeric(N)  # Вектор для доходностей

for (n in 1:N) {
  # Генерируем случайную доходность
  if (rbinom(1, 1, p) == 1) {
    rho[n] <- b  # Если удача, то b
  } else {
    rho[n] <- a  # Если неудача, то a
  }
}

# Рассчитываем последовательность Sn
for (n in 2:(N + 1)) {
  S[n] <- (1 + rho[n - 1]) * S[n - 1]
}

# Строим график изменения Sn
plot(0:N, S, type = "l", col = "red", lwd = 2,
     xlab = "Период n", ylab = "Значение Sn",
     main = "Изменение цены акции Sn при случайных доходностях")
grid()  # Добавляем сетку

# Задание 3 ----

# Параметры для расчета цены опциона
S0 <- 100  # Начальная цена акции
N <- 10    # Время до исполнения опциона
a <- -0.3  # Плохая доходность
b <- 0.8   # Хорошая доходность
r <- 0.2   # Процентная ставка
K <- 100   # Цена исполнения (strike price)

# Считаем вероятности для формулы
p_tilde <- (r - a) / (b - a) # p с тильдой
p_star <- ((1 + b) / (1 + r)) * p_tilde  # p*

# Рассчитываем K0
K0 <- 1 + floor(log(K / (S0 * (1 + a)^N)) / log((1 + b) / (1 + a)))

# Функция для биномиального коэффициента
binom_coeff <- function(n, k) {
  factorial(n) / (factorial(k) * factorial(n - k))
}

# Функция для расчета суммы B(j, N; p)
B_func <- function(j, N, p) {
  sum <- 0
  for (k in j:N) {
    sum <- sum + binom_coeff(N, k) * p^k * (1 - p)^(N - k)
  }
  return(sum)
}

# Считаем справедливую цену опциона
if (K0 <= N) {
  call_price <- S0 * B_func(K0, N, p_star) - K * (1 + r)^(-N) * B_func(K0, N, p_tilde)
} else {
  call_price <- 0  # Если K0 больше N, то цена 0
}

# Выводим результат
call_price
